import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'DeviceGraphPage.dart';
import 'Shared_Add_Device.dart'; 

class AdminPage extends StatefulWidget {
  const AdminPage({Key? key}) : super(key: key);

  @override
  State<AdminPage> createState() => _AdminPageState();
}double getResponsiveFontSize(BuildContext context, double mobileSize, double desktopSize) {
  final width = MediaQuery.of(context).size.width;
  return width <= 600 ? mobileSize :desktopSize;
}

class _AdminPageState extends State<AdminPage> {
  final String apiUrl =
      "https://xa9ry8sls0.execute-api.us-east-1.amazonaws.com/CloudSense_device_activity_api_function";
  final String userApiUrl =
      "https://25e5bsdhwd.execute-api.us-east-1.amazonaws.com/default/CloudSense_users_delete_function";
  final String flaggingApiUrl = "https://hmnrva928j.execute-api.us-east-1.amazonaws.com/default/WS_Flag_API";
  final String userDevicesApiUrl = "https://ln8b1r7ld9.execute-api.us-east-1.amazonaws.com/default/Cloudsense_user_devices";
  final String addDeviceApiUrl = "https://ymfmk699j5.execute-api.us-east-1.amazonaws.com/default/Cloudsense_user_add_devices";

  bool isLoading = true;
  List<Map<String, dynamic>> allDevices = [];
  int totalActive = 0;
  int totalInactive = 0;
  String filter = "All";
  String searchQuery = "";
  List<Map<String, String>> users = [];
  bool isUsersLoading = true;
  Map<String, String> anomalies = {};
  List<String> seenAnomalies = [];
  List<Map<String, String>> notifications = [];
  List<Map<String, String>> dismissedNotifications = [];
  Timer? _anomalyTimer;
  FlutterLocalNotificationsPlugin? _notificationsPlugin;

  int devicesToShow = 4; // start with 4 devices
  int usersToShow = 4;   // start with 4 users


  @override
  void initState() {
    super.initState();
    _loadPrefs();
    fetchDevices();
    fetchUsers();
    if (!kIsWeb) {
      _initializeNotifications();
    }
    fetchAnomalies();
    _anomalyTimer = Timer.periodic(Duration(seconds: 30), (_) => fetchAnomalies());
  }

  Future<void> _loadPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final notifsJson = prefs.getString('notifications');
    if (notifsJson != null) {
      final decoded = json.decode(notifsJson) as List;
      notifications = decoded.map((item) => Map<String, String>.from(item)).toList();
    }
    final dismissedJson = prefs.getString('dismissedNotifications');
    if (dismissedJson != null) {
      final decoded = json.decode(dismissedJson) as List;
      dismissedNotifications = decoded.map((item) => Map<String, String>.from(item)).toList();
    }
    setState(() {});
  }

  Future<void> _savePrefs() async {
    final prefs = await SharedPreferences.getInstance();
    prefs.setString('notifications', json.encode(notifications));
    prefs.setString('dismissedNotifications', json.encode(dismissedNotifications));
  }

  @override
  void dispose() {
    _anomalyTimer?.cancel();
    super.dispose();
  }

  Future<void> _initializeNotifications() async {
    _notificationsPlugin = FlutterLocalNotificationsPlugin();
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosInit = DarwinInitializationSettings();
    const initSettings = InitializationSettings(android: androidInit, iOS: iosInit);
    await _notificationsPlugin!.initialize(
      initSettings,
      onDidReceiveNotificationResponse: (response) {
        if (response.payload != null) {
          _handleNotificationTap(response.payload!);
        }
      },
    );
  }
Future<void> fetchAnomalies() async {
  final newNotifications = <Map<String, String>>[];
  final failedDevices = <String, int>{}; // Track failed attempts per device

  for (final d in allDevices) {
    final deviceId = d['DeviceId'] ?? "";
    final topic = d['Topic'] ?? "Unknown";
    if (deviceId.isEmpty || !topic.contains('WS/Campus')) continue;
    final deviceIdTopic = "$deviceId#$topic";

    // Initialize failure count if not exists
    failedDevices[deviceId] = failedDevices[deviceId] ?? 0;

    // Skip devices with too many failures (e.g., 5 failed attempts)
    if (failedDevices[deviceId]! >= 5) {
      if (kDebugMode) {
        print("Skipping device $deviceId due to repeated failures");
      }
      continue;
    }

    try {
      final response = await http.get(Uri.parse("$flaggingApiUrl?DeviceID=$deviceId")).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw TimeoutException("Request to $flaggingApiUrl timed out for device $deviceId");
        },
      );
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        failedDevices[deviceId] = 0; // Reset failure count on success
        if (data is List && data.isNotEmpty) {
          for (final item in data) {
            final anomaly = item['Anomaly']?.toString() ?? "";
            final timestamp = item['Timestamp']?.toString() ?? "N/A";
            if (anomaly.isNotEmpty) {
              final isAlreadyNotified = notifications.any(
                (n) => n['deviceIdTopic'] == deviceIdTopic && n['timestamp'] == timestamp,
              );
              final isDismissed = dismissedNotifications.any(
                (dn) => dn['deviceIdTopic'] == deviceIdTopic && dn['timestamp'] == timestamp,
              );
              if (!isAlreadyNotified && !isDismissed) {
                final message = _buildNotificationMessage(deviceIdTopic, anomaly, timestamp);
                newNotifications.add({
                  'deviceIdTopic': deviceIdTopic,
                  'message': message,
                  'anomaly': anomaly,
                  'timestamp': timestamp,
                });
                final uniqueId = "$deviceIdTopic#$timestamp";
                _showNotification(uniqueId, message);
              }
            }
          }
        }
      } else {
        failedDevices[deviceId] = failedDevices[deviceId]! + 1;
        if (kDebugMode) {
          print("Flagging API error for $deviceId: ${response.statusCode}");
        }
      }
    } catch (e) {
      failedDevices[deviceId] = failedDevices[deviceId]! + 1;
      if (kDebugMode) {
        print("Flagging API Exception for $deviceId: $e");
      }
      if (failedDevices[deviceId]! >= 5) {
        _toast("Persistent error fetching anomalies for device $deviceId. Skipping further attempts.");
      }
    }
  }

  if (newNotifications.isNotEmpty) {
    setState(() {
      notifications.addAll(newNotifications);
      notifications.sort((a, b) {
        final da = parseDate(a['timestamp']) ?? DateTime(0);
        final db = parseDate(b['timestamp']) ?? DateTime(0);
        return db.compareTo(da); // Sort newest first
      });
    });
    await _savePrefs();
  } else {
    setState(() {});
  }
  if (kDebugMode) {
    print("Notifications: $notifications");
    print("Failed devices: $failedDevices");
  }
}
  String _buildNotificationMessage(String deviceIdTopic, String anomaly, String timestamp) {
    final deviceId = deviceIdTopic.split('#')[0];
    final topic = deviceIdTopic.split('#').length > 1 ? deviceIdTopic.split('#')[1] : "Unknown";
    final mapped = _mapCategoryAndPrefix(topic);
    final sensorName = mapped.prefix.isNotEmpty ? "${mapped.prefix}${deviceId.padLeft(3, '0')}" : deviceId;
    return "Anomaly in Device $sensorName: $anomaly at $timestamp";
  }

  Future<void> _showNotification(String uniqueId, String message) async {
    if (kIsWeb) {
      return;
    } else {
      const androidDetails = AndroidNotificationDetails(
        'anomaly_channel',
        'Anomaly Alerts',
        channelDescription: 'Notifications for device anomalies',
        importance: Importance.high,
        priority: Priority.high,
      );
      const iosDetails = DarwinNotificationDetails();
      const platformDetails = NotificationDetails(android: androidDetails, iOS: iosDetails);
      await _notificationsPlugin!.show(
        uniqueId.hashCode,
        'Device Anomaly',
        message,
        platformDetails,
        payload: uniqueId,
      );
    }
  }

  void _handleNotificationTap(String payload) {
    final parts = payload.split('#');
    if (parts.length != 3) {
      _toast("Invalid notification data");
      return;
    }
    final deviceId = parts[0];
    final topic = parts[1];
    final timestamp = parts[2];
    final deviceIdTopic = '$deviceId#$topic';

    final notification = notifications.firstWhere(
      (n) => n['deviceIdTopic'] == deviceIdTopic && n['timestamp'] == timestamp,
      orElse: () => {},
    );
    if (notification.isEmpty) {
      _toast("Notification not found");
      return;
    }

    final device = filteredDevices.asMap().entries.firstWhere(
          (entry) => entry.value['DeviceId'] == deviceId && entry.value['Topic'] == topic,
          orElse: () => MapEntry(-1, {}),
        );
    if (device.key != -1) {
      final d = device.value;
      final mapped = _mapCategoryAndPrefix(topic);
      final sensorName = mapped.prefix.isNotEmpty ? "${mapped.prefix}${deviceId.padLeft(3, '0')}" : deviceId;
      final sequentialName = "${mapped.category}";
      final anomalyMessage = notification['anomaly'] ?? "No anomaly data available";

      if (kDebugMode) {
        print("Handling notification tap for payload: $payload");
        print("Device: $d");
        print("Anomaly: $anomalyMessage");
        print("Last Received Time: ${d['lastReceivedTime']}");
      }

      showDialog(
        context: context,
        builder: (_) => AlertDialog(
          title: Text("Anomaly Details for $sensorName"),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Device ID: $deviceId"),
              const SizedBox(height: 6),
              Text("Topic: $topic"),
              const SizedBox(height: 6),
              Text("Anomaly: $anomalyMessage"),
            
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Close"),
            ),
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => DeviceGraphPage(
                      deviceName: sensorName,
                      sequentialName: sequentialName,
                      backgroundImagePath: 'assets/backgroundd.jpg',
                    ),
                  ),
                );
              },
              child: const Text("View Device"),
            ),
          ],
        ),
      );
    } else {
      _toast("Device not found for $deviceIdTopic");
      if (kDebugMode) {
        print("Device not found for deviceIdTopic: $deviceIdTopic");
      }
    }
  }

  void _dismissNotification(String deviceIdTopic, String timestamp) {
    setState(() {
      final notificationIndex = notifications.indexWhere(
        (n) => n['deviceIdTopic'] == deviceIdTopic && n['timestamp'] == timestamp,
      );
      if (notificationIndex != -1) {
        final notification = notifications[notificationIndex];
        dismissedNotifications.add({
          'deviceIdTopic': deviceIdTopic,
          'anomaly': notification['anomaly'] ?? "",
          'timestamp': timestamp,
        });
        notifications.removeAt(notificationIndex);
        if (!kIsWeb) {
          final uniqueId = "$deviceIdTopic#$timestamp";
          _notificationsPlugin?.cancel(uniqueId.hashCode);
        }
      }
    });
    _savePrefs();
  }

  void _showNotificationsDialog() {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final subtle = isDark ? Colors.white70 : Colors.black54;
    final strong = isDark ? Colors.white : Colors.black;

    showDialog(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (dialogContext, dialogSetState) {
          final ScrollController scrollController = ScrollController();

          Map<String, List<Map<String, String>>> groupedNotifications = {};
          for (var n in notifications) {
            final key = n['deviceIdTopic']!;
            groupedNotifications.putIfAbsent(key, () => []).add(n);
          }

          groupedNotifications.forEach((key, list) {
            list.sort((a, b) {
              final da = parseDate(a['timestamp']) ?? DateTime(0);
              final db = parseDate(b['timestamp']) ?? DateTime(0);
              return db.compareTo(da);
            });
          });

          final sortedKeys = groupedNotifications.keys.toList();
          sortedKeys.sort((a, b) {
            final ta = parseDate(groupedNotifications[a]![0]['timestamp']) ?? DateTime(0);
            final tb = parseDate(groupedNotifications[b]![0]['timestamp']) ?? DateTime(0);
            return tb.compareTo(ta);
          });

          return Dialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Container(
              constraints: const BoxConstraints(maxWidth: 400, maxHeight: 400),
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        "Notifications (${notifications.length})",
                        style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800),
                      ),
                      IconButton(
                        icon: Icon(Icons.close, color: subtle),
                        onPressed: () => Navigator.pop(dialogContext),
                        tooltip: 'Close',
                      ),
                    ],
                  ),
                  const Divider(height: 1),
                  const SizedBox(height: 8),
                  Expanded(
                    child: notifications.isEmpty
                        ? Center(child: Text("No notifications", style: TextStyle(color: subtle)))
                        : Scrollbar(
                            thumbVisibility: true,
                            controller: scrollController,
                            child: ListView.separated(
                              controller: scrollController,
                              itemCount: sortedKeys.length,
                              separatorBuilder: (_, __) => Divider(color: subtle.withOpacity(.12)),
                              itemBuilder: (_, i) {
                                final key = sortedKeys[i];
                                final deviceNotifs = groupedNotifications[key]!;
                                final latest = deviceNotifs[0];
                                final hasMore = deviceNotifs.length > 1;
                                return ListTile(
                                  leading: Icon(Icons.warning, color: Colors.orange),
                                  title: Text(
                                    latest['message']!,
                                    style: TextStyle(color: strong, fontSize: 12,fontWeight: FontWeight.w600),
                                  ),
                                  trailing: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      if (hasMore)
                                        GestureDetector(
                                          onTap: () {
                                            _showDeviceNotificationsDialog(dialogContext, key, dialogSetState);
                                          },
                                          child: Container(
                                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                            decoration: BoxDecoration(
                                              color: Colors.blue,
                                              borderRadius: BorderRadius.circular(12),
                                            ),
                                            child: Text(
                                              "+${deviceNotifs.length - 1}",
                                              style: const TextStyle(color: Colors.white, fontSize: 12),
                                            ),
                                          ),
                                        ),
                                      const SizedBox(width: 8),
                                      IconButton(
                                        icon: Icon(Icons.delete, color: Colors.red),
                                        onPressed: () {
                                          dialogSetState(() {
                                            _dismissNotification(key, latest['timestamp']!);
                                          });
                                        },
                                        tooltip: 'Dismiss',
                                      ),
                                    ],
                                  ),
                                  onTap: () {
                                    Navigator.pop(dialogContext);
                                    _handleNotificationTap("$key#${latest['timestamp']!}");
                                  },
                                );
                              },
                            ),
                          ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  void _showDeviceNotificationsDialog(BuildContext dialogContext, String deviceIdTopic, StateSetter dialogSetState) {
    final deviceId = deviceIdTopic.split('#')[0];
    final topic = deviceIdTopic.split('#')[1];
    final mapped = _mapCategoryAndPrefix(topic);
    final sensorName = mapped.prefix.isNotEmpty ? "${mapped.prefix}${deviceId.padLeft(3, '0')}" : deviceId;

    showDialog(
      context: dialogContext,
      builder: (subContext) => StatefulBuilder(
        builder: (subContext, subSetState) {
          final deviceNotifs = notifications
              .where((n) => n['deviceIdTopic'] == deviceIdTopic)
              .toList()
            ..sort((a, b) {
              final da = parseDate(a['timestamp']) ?? DateTime(0);
              final db = parseDate(b['timestamp']) ?? DateTime(0);
              return db.compareTo(da);
            });

          if (deviceNotifs.isEmpty) {
            WidgetsBinding.instance.addPostFrameCallback((_) => Navigator.pop(subContext));
            return const SizedBox();
          }

          final theme = Theme.of(subContext);
          final isDark = theme.brightness == Brightness.dark;
          final subtle = isDark ? Colors.white70 : Colors.black54;
          final strong = isDark ? Colors.white : Colors.black;

          return Dialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Container(
              constraints: const BoxConstraints(maxWidth: 400, maxHeight: 400),
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        "Notifications for $sensorName (${deviceNotifs.length})",
                        style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800),
                      ),
                      IconButton(
                        icon: Icon(Icons.close, color: subtle),
                        onPressed: () => Navigator.pop(subContext),
                        tooltip: 'Close',
                      ),
                    ],
                  ),
                  const Divider(height: 1),
                  const SizedBox(height: 8),
                  Expanded(
                    child: ListView.separated(
                      itemCount: deviceNotifs.length,
                      separatorBuilder: (_, __) => Divider(color: subtle.withOpacity(.12)),
                      itemBuilder: (_, i) {
                        final n = deviceNotifs[i];
                        return ListTile(
                          leading: Icon(Icons.warning, color: Colors.orange),
                          title: Text(
                            n['message']!,
                            style: TextStyle(color: strong, fontSize: 12, fontWeight: FontWeight.w600),
                          ),
                          trailing: IconButton(
                            icon: Icon(Icons.delete, color: Colors.red),
                            onPressed: () {
                              _dismissNotification(deviceIdTopic, n['timestamp']!);
                              subSetState(() {});
                              dialogSetState(() {});
                            },
                            tooltip: 'Dismiss',
                          ),
                          onTap: () {
                            Navigator.pop(subContext);
                            Navigator.pop(dialogContext);
                            _handleNotificationTap("$deviceIdTopic#${n['timestamp']!}");
                          },
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> fetchDevices() async {
    setState(() => isLoading = true);
    try {
      final response = await http.get(Uri.parse(apiUrl));
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final keysToInclude = [
          'WS_Device_Activity',
          'Awadh_Jio_Device_Activity',
          'weather_Device_Activity',
        ];

        final List<Map<String, dynamic>> devices = [];
        for (final key in keysToInclude) {
          final list = data[key];
          if (list is List) {
            for (final device in list) {
              final topic = device['Topic']?.toString() ?? "Unknown";
              if (topic.startsWith('BF/') || topic.startsWith('CS/')) {
                continue;
              }
              final DateTime? lastTime = parseDate(device['lastReceivedTime']);
              bool isActive = false;
              if (lastTime != null) {
                final diff = DateTime.now().difference(lastTime);
                isActive = diff.inHours <= 24;
              }
              devices.add({
                "DeviceId": device['DeviceId']?.toString() ?? "Unknown",
                "lastReceivedTime": lastTime?.toString() ?? "N/A",
                "isActive": isActive,
                "group": key,
                "Topic": topic,
                "LastKnownLongitude": device['LastKnownLongitude']?.toString() ?? "0",
                "LastKnownLatitude": device['LastKnownLatitude']?.toString() ?? "0",
              });
            }
          }
        }

        final int activeCount = devices.where((d) => d['isActive'] == true).length;
        final int inactiveCount = devices.length - activeCount;

        setState(() {
          allDevices = devices;
          totalActive = activeCount;
          totalInactive = inactiveCount;
          isLoading = false;
        });

        if (kDebugMode) {
          // print("Fetched devices: $devices");
        }
      } else {
        setState(() => isLoading = false);
        _toast("Device API error: ${response.statusCode}");
      }
    } catch (e) {
      setState(() => isLoading = false);
      _toast("Device fetch failed");
      if (kDebugMode) debugPrint("fetchDevices error: $e");
    }
  }

  Future<void> fetchUsers() async {
    setState(() => isUsersLoading = true);
    for (int attempt = 1; attempt <= 3; attempt++) {
      try {
        final response = await http.get(Uri.parse("$userApiUrl?action=list")).timeout(Duration(seconds: 10));
        if (response.statusCode == 200) {
          final data = json.decode(response.body);
          List<Map<String, String>> userList = [];

          if (data is Map && data.containsKey('users') && data['users'] is List) {
            userList = (data['users'] as List).map<Map<String, String>>((email) {
              return {
                "email": email.toString(),
                "name": email.toString().split('@')[0],
                "role": "User",
              };
            }).toList();
          }

          setState(() {
            users = userList;
            isUsersLoading = false;
          });

          if (users.isEmpty) {
            _toast("No valid user data received");
          }
          return;
        } else {
          if (attempt == 3) {
            setState(() => isUsersLoading = false);
            _toast("User API error: ${response.statusCode}");
            return;
          }
        }
      } catch (e) {
        if (attempt == 3) {
          setState(() => isUsersLoading = false);
          _toast("User fetch failed: $e");
        }
      }
      await Future.delayed(Duration(seconds: 2));
    }
  }

  Future<void> _showUserDevices(String email) async {
    Map<String, List<String>> deviceCategories = {};
    bool isLoadingDevices = true;

    try {
      final response = await http.get(Uri.parse("$userDevicesApiUrl?email_id=$email"));
      if (response.statusCode == 200) {
        final result = json.decode(response.body);
        deviceCategories = {
          for (var key in result.keys)
            if (key != 'device_id' && key != 'email_id')
              key: List<String>.from(result[key] ?? [])
        };
      } else {
        _toast("Failed to load devices: Status ${response.statusCode}");
      }
    } catch (e) {
      _toast("Error fetching devices: $e");
    } finally {
      isLoadingDevices = false;
    }

    if (!mounted) return;
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final subtle = isDark ? Colors.white70 : Colors.black54;
    final strong = isDark ? Colors.white : Colors.black;

    showDialog(
      context: context,
      builder: (dialogContext) => StatefulBuilder(
        builder: (dialogContext, dialogSetState) {
          Future<void> _refreshDevices() async {
            dialogSetState(() => isLoadingDevices = true);
            try {
              final response = await http.get(Uri.parse("$userDevicesApiUrl?email_id=$email"));
              if (response.statusCode == 200) {
                final result = json.decode(response.body);
                dialogSetState(() {
                  deviceCategories = {
                    for (var key in result.keys)
                      if (key != 'device_id' && key != 'email_id')
                        key: List<String>.from(result[key] ?? [])
                  };
                });
              } else {
                _toast("Failed to load devices: Status ${response.statusCode}");
              }
            } catch (e) {
              _toast("Error fetching devices: $e");
            }
            dialogSetState(() => isLoadingDevices = false);
          }

          return Dialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Container(
              constraints: const BoxConstraints(maxWidth: 600, maxHeight: 400),
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        "Devices for $email",
                        style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800),
                      ),
                      Row(
                        children: [
                          IconButton(
                            icon: Icon(Icons.refresh, color: subtle),
                            onPressed: _refreshDevices,
                            tooltip: 'Refresh',
                          ),
                          IconButton(
                            icon: Icon(Icons.close, color: subtle),
                            onPressed: () => Navigator.pop(dialogContext),
                          ),
                        ],
                      ),
                    ],
                  ),
                  const Divider(height: 1),
                  const SizedBox(height: 8),
                  Expanded(
                    child: isLoadingDevices
                        ? const Center(child: CircularProgressIndicator())
                        : deviceCategories.isEmpty
                            ? Center(child: Text("No devices found", style: TextStyle(color: subtle)))
                            : ListView.builder(
                                itemCount: deviceCategories.keys.length,
                                itemBuilder: (ctx, index) {
                                  final category = deviceCategories.keys.elementAt(index);
                                  final devices = deviceCategories[category]!;
                                  return ExpansionTile(
                                    title: Text(
                                      category.trim(),
                                      style: TextStyle(
                                        color: strong,
                                        fontWeight: FontWeight.bold,
                                        fontSize: 16,
                                      ),
                                    ),
                                    children: devices.map((device) {
                                      return ListTile(
                                        title: Text(
                                          'â€¢ $device',
                                          style: TextStyle(color: strong, fontSize: 14),
                                        ),
                                        trailing: IconButton(
                                          icon: Icon(Icons.delete, color: Colors.red),
                                          onPressed: () async {
                                            final confirm = await showDialog<bool>(
                                              context: dialogContext,
                                              builder: (confirmCtx) => AlertDialog(
                                                title: const Text("Confirm Deletion"),
                                                content: Text("Are you sure you want to delete device $device from $email?"),
                                                actions: [
                                                  TextButton(
                                                    onPressed: () => Navigator.pop(confirmCtx, false),
                                                    child: const Text("Cancel"),
                                                  ),
                                                  TextButton(
                                                    onPressed: () => Navigator.pop(confirmCtx, true),
                                                    child: const Text("Delete", style: TextStyle(color: Colors.red)),
                                                  ),
                                                ],
                                              ),
                                            );
                                            if (confirm == true) {
                                              await _deleteUserDevice(email, device, dialogContext, dialogSetState);
                                              // Check if there are any devices left
                                              if (deviceCategories.values.every((devices) => devices.isEmpty)) {
                                                Navigator.pop(dialogContext); // Close dialog if no devices remain
                                              } else {
                                                await _refreshDevices();
                                              }
                                            }
                                          },
                                          tooltip: 'Delete',
                                        ),
                                      );
                                    }).toList(),
                                  );
                                },
                              ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _deleteUserDevice(String email, String deviceId, BuildContext dialogContext, StateSetter dialogSetState) async {
    final url = "$userApiUrl?email_id=$email&action=delete_devices&device_id=$deviceId";
    try {
      final response = await http.delete(Uri.parse(url));
      if (response.statusCode == 200) {
        try {
          final body = json.decode(response.body);
          if (body['message']?.toString().toLowerCase().contains('deleted') == true) {
            _toast("Device $deviceId deleted from $email");
            // Remove any related notifications and anomalies
            final deviceIdTopic = allDevices
                .firstWhere((d) => d['DeviceId'] == deviceId, orElse: () => {'Topic': ''})['Topic']
                .toString();
            final fullDeviceIdTopic = "$deviceId#$deviceIdTopic";
            dialogSetState(() {
              notifications.removeWhere((n) => n['deviceIdTopic'] == fullDeviceIdTopic);
              anomalies.remove(fullDeviceIdTopic);
              dismissedNotifications.removeWhere((n) => n['deviceIdTopic'] == fullDeviceIdTopic);
            });
            if (!kIsWeb) {
              for (var n in notifications.where((n) => n['deviceIdTopic'] == fullDeviceIdTopic)) {
                final uniqueId = "$fullDeviceIdTopic#${n['timestamp']}";
                _notificationsPlugin?.cancel(uniqueId.hashCode);
              }
            }
            await _savePrefs();
          } else {
            _toast("Failed to delete device: ${body['message'] ?? 'Unknown error'}");
          }
        } on FormatException {
          if (response.body.toLowerCase().contains('deleted')) {
            _toast("Device $deviceId deleted from $email");
            final deviceIdTopic = allDevices
                .firstWhere((d) => d['DeviceId'] == deviceId, orElse: () => {'Topic': ''})['Topic']
                .toString();
            final fullDeviceIdTopic = "$deviceId#$deviceIdTopic";
            dialogSetState(() {
              notifications.removeWhere((n) => n['deviceIdTopic'] == fullDeviceIdTopic);
              anomalies.remove(fullDeviceIdTopic);
              dismissedNotifications.removeWhere((n) => n['deviceIdTopic'] == fullDeviceIdTopic);
            });
            if (!kIsWeb) {
              for (var n in notifications.where((n) => n['deviceIdTopic'] == fullDeviceIdTopic)) {
                final uniqueId = "$fullDeviceIdTopic#${n['timestamp']}";
                _notificationsPlugin?.cancel(uniqueId.hashCode);
              }
            }
            await _savePrefs();
          } else {
            _toast("Failed to delete device: ${response.body}");
          }
        }
      } else {
        _toast("Delete API error: Status ${response.statusCode}, Body: ${response.body}");
      }
    } catch (e) {
      _toast("Error deleting device: $e");
      if (kDebugMode) print("Delete device error: $e");
    }
  }

  Future<void> _addDeviceToUser(String email, String deviceId) async {
    try {
      if (!DeviceUtils.isValidDeviceId(deviceId)) {
        _toast("Invalid Device ID.");
        return;
      }

      final deviceExists = allDevices.any((d) => d['DeviceId'] == deviceId);
      if (deviceExists) {
        _toast("Device $deviceId is already added.");
        return;
      }

      final response = await http.get(Uri.parse("$addDeviceApiUrl?email_id=$email&device_id=$deviceId"));
      if (kDebugMode) {
        print("Add Device Response: Status=${response.statusCode}, Body=${response.body}");
      }

      if (response.statusCode == 200) {
        try {
          final responseBody = json.decode(response.body);
          if (responseBody['message']?.toString().toLowerCase().contains('success') == true) {
            _toast("Device $deviceId added to $email successfully");
          } else {
            _toast("Failed to add device: ${responseBody['message'] ?? 'Unknown error'}");
          }
        } on FormatException {
          if (response.body.toLowerCase().contains('success')) {
            _toast("Device $deviceId added to $email successfully");
          } else {
            _toast("Failed to add device: ${response.body}");
          }
        }
      } else {
        _toast("Add device API error: Status ${response.statusCode}, ${response.body}");
      }
    } catch (e) {
      _toast("Error adding device: $e");
      if (kDebugMode) {
        print("Exception during device addition: $e");
      }
    }
  }

  void _showAddDeviceDialog(String email) {
    final TextEditingController deviceIdController = TextEditingController();

    showDialog(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (context, setState) {
          return AlertDialog(
            title: Text("Add Device to $email"),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: deviceIdController,
                  decoration: InputDecoration(
                    labelText: "Enter Device ID (e.g., CP001)",
                    border: OutlineInputBorder(),
                    helperText: "Use 2 uppercase letters (e.g., CP) + 3 digits (e.g., 001)",
                  ),
                  onChanged: (value) {
                    setState(() {});
                  },
                ),
              ],
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text("Cancel"),
              ),
              TextButton(
                onPressed: deviceIdController.text.trim().isEmpty
                    ? null
                    : () {
                        final deviceId = deviceIdController.text.trim();
                        if (!DeviceUtils.isValidDeviceId(deviceId)) {
                          _toast("Invalid Device ID.");
                          return;
                        }
                        Navigator.pop(context);
                        _addDeviceToUser(email, deviceId);
                      },
                child: const Text("Add"),
              ),
            ],
          );
        },
      ),
    );
  }

  DateTime? parseDate(String? dateStr) {
    if (dateStr == null || dateStr == "N/A") return null;
    try {
      final compactRegex = RegExp(r'^\d{8}T\d{6}$');
      if (compactRegex.hasMatch(dateStr)) {
        final y = int.parse(dateStr.substring(0, 4));
        final m = int.parse(dateStr.substring(4, 6));
        final d = int.parse(dateStr.substring(6, 8));
        final H = int.parse(dateStr.substring(9, 11));
        final M = int.parse(dateStr.substring(11, 13));
        final S = int.parse(dateStr.substring(13, 15));
        return DateTime(y, m, d, H, M, S);
      }
      return DateTime.tryParse(dateStr.replaceAll('  ', ' '));
    } catch (_) {
      return null;
    }
  }

  List<Map<String, dynamic>> get filteredDevices {
    Iterable<Map<String, dynamic>> list = allDevices;
    if (filter == "Active") {
      list = list.where((d) => d['isActive'] == true);
    } else if (filter == "Inactive") {
      list = list.where((d) => d['isActive'] == false);
    }
    if (searchQuery.isNotEmpty) {
      final q = searchQuery.toLowerCase();
      list = list.where((d) =>
          d['DeviceId'].toString().toLowerCase().contains(q) ||
          d['group'].toString().toLowerCase().contains(q) ||
          d['Topic'].toString().toLowerCase().contains(q));
    }
    final sorted = list.toList()
      ..sort((a, b) {
        if (a['isActive'] == b['isActive']) {
          return a['DeviceId'].toString().compareTo(b['DeviceId'].toString());
        }
        return a['isActive'] ? -1 : 1;
      });
    return sorted;
  }

  void _toast(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  ({String category, String prefix}) _mapCategoryAndPrefix(String topic) {
    if (topic == 'WS/Campus/2') {
      return (category: 'Sekhon Farm Sensor', prefix: 'CF');
    }
    if (topic.contains('WS/Campus')) {
      return (category: 'IIT Ropar Sensor', prefix: 'CP');
    }
    if (topic.contains('WS/SSMet/NARL')) {
      return (category: 'NARL Sensor', prefix: 'NA');
    }
    if (topic.contains('WS/SSMet/KJSCE')) {
      return (category: 'KJ Sensor', prefix: 'KJ');
    }
    if (topic.contains('WS/SSMet')) {
      return (category: 'SSMET Sensor', prefix: 'SM');
    }
    if (topic.contains('WS/SVPU')) {
      return (category: 'SVPU Sensor', prefix: 'SV');
    }
    if (topic.contains('WS/Mysuru')) {
      return (category: 'Mysuru NIE Sensor', prefix: 'MY');
    }
    if (topic.contains('WS/KARGIL')) {
      return (category: 'Kargil Sensor', prefix: 'KD');
    }
    if (topic.contains('IIT/WS')) {
      return (category: 'IIT Bombay Sensor', prefix: 'IT');
    }
    return (category: 'Unknown Sensor', prefix: '');
  }

  Future<void> _deleteUser(String email) async {
    final url = "$userApiUrl?email_id=$email&action=delete_user";
    try {
      final response = await http.delete(Uri.parse(url));
      if (response.statusCode == 200) {
        final responseBody = json.decode(response.body);
        if (responseBody is Map && responseBody['message']?.toString().toLowerCase().contains('confirm_delete=yes') == true) {
          if (!mounted) return;
          showDialog(
            context: context,
            builder: (_) => AlertDialog(
              title: const Text("Confirm Deletion"),
              content: Text("Are you sure you want to delete the user $email?"),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text("Cancel"),
                ),
                TextButton(
                  onPressed: () async {
                    Navigator.pop(context);
                    final confirmUrl = "$userApiUrl?email_id=$email&action=delete_user&confirm_delete=yes";
                    try {
                      final confirmResponse = await http.delete(Uri.parse(confirmUrl));
                      if (confirmResponse.statusCode == 200) {
                        final confirmResponseBody = json.decode(confirmResponse.body);
                        if (confirmResponseBody is Map && confirmResponseBody['message']?.toString().toLowerCase().contains('deleted') == true) {
                          _toast("User $email deleted successfully");
                          await fetchUsers();
                        } else {
                          _toast("Failed to delete user $email: ${confirmResponseBody['message'] ?? 'Unknown error'}");
                        }
                      } else if (confirmResponse.statusCode == 404) {
                        _toast("User $email not found, treated as deleted");
                        await fetchUsers();
                      } else {
                        _toast("Failed to delete user $email: Status ${confirmResponse.statusCode}");
                      }
                    } catch (e) {
                      _toast("Error deleting user $email: $e");
                      if (kDebugMode) debugPrint("confirmDeleteUser error: $e");
                    }
                  },
                  child: const Text("Delete", style: TextStyle(color: Colors.red)),
                ),
              ],
            ),
          );
        } else if (responseBody is Map && responseBody['message']?.toString().toLowerCase().contains('deleted') == true) {
          _toast("User $email deleted successfully");
          await fetchUsers();
        } else {
          _toast("Failed to delete user $email: ${responseBody['message'] ?? 'Unknown error'}");
        }
      } else if (response.statusCode == 404) {
        _toast("User $email not found, treated as deleted");
        await fetchUsers();
      } else {
        _toast("Failed to delete user $email: Status ${response.statusCode}");
      }
    } catch (e) {
      _toast("Error deleting user $email: $e");
      if (kDebugMode) debugPrint("deleteUser error: $e");
    }
  }

  List<PieChartSectionData> _pieSections() {
    final double active = (totalActive > 0) ? totalActive.toDouble() : 0;
    final double inactive = (totalInactive > 0) ? totalInactive.toDouble() : 0;
    final total = active + inactive;
    if (total == 0) {
      return [
        PieChartSectionData(
          color: Colors.grey.shade400,
          value: 1,
          title: 'No Data',
          radius: 46,
          titleStyle: TextStyle(fontSize: 12, color: Colors.white),
        )
      ];
    }
    return [
      PieChartSectionData(
        color: Colors.green,
        value: active,
        title: '${((active / total) * 100).toStringAsFixed(0)}%',
        radius: 48,
        titleStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.white),
      ),
      PieChartSectionData(
        color: Colors.red,
        value: inactive,
        title: '${((inactive / total) * 100).toStringAsFixed(0)}%',
        radius: 48,
        titleStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.white),
      ),
    ];
  }

@override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    // ðŸ”¹ Use gradient colors instead of a flat bg color
    final bg = isDark
        ? [
            const Color.fromARGB(255, 4, 36, 49),
            const Color.fromARGB(255, 2, 54, 76),
          ]
        : [
            const Color.fromARGB(255, 191, 242, 237),
            const Color.fromARGB(255, 79, 106, 112),
          ];

    final card = isDark ? const Color(0xFF161A22) : Colors.white;
    final subtle = isDark ? Colors.white70 : Colors.black54;
    final strong = isDark ? Colors.white : Colors.black;


    return Scaffold(
      backgroundColor: bg.first,
      appBar: AppBar(
       elevation: 0, // remove shadow
        scrolledUnderElevation: 0, // NEW: disables the lighter overlay effect when scrolled
        surfaceTintColor: Colors.transparent, // prevents automatic tint
        backgroundColor: bg.first,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: strong),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(
          'Admin Dashboard',
          style: TextStyle(
            color: strong,
            fontWeight: FontWeight.w700,
            letterSpacing: 0.2,
          ),
        ),
        actions: [
          if (kIsWeb)
            Stack(
              children: [
                IconButton(
                  tooltip: 'Notifications',
                  onPressed: _showNotificationsDialog,
                  icon: Icon(Icons.notifications, color: strong),
                ),
                if (notifications.isNotEmpty)
                  Positioned(
                    right: 8,
                    top: 8,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.red,
                        shape: BoxShape.circle,
                        
                      ),
                      constraints: const BoxConstraints(minWidth: 16, minHeight: 16),
                      child: Text(
                        '${notifications.length}',
                        style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ),
              ],
            ),
          IconButton(
            tooltip: 'Refresh devices',
            onPressed: () {
              fetchDevices();
              fetchAnomalies();
            },
            icon: Icon(Icons.refresh, color: strong),
          ),
        ],
      ),
      body: LayoutBuilder(
        builder: (context, constraints) {
          // Define screen size categories
          final isMobile = constraints.maxWidth <= 600;
          final isTablet = constraints.maxWidth > 600 && constraints.maxWidth <= 1024;
          final isLargeScreen = constraints.maxWidth > 1024;

          // Set layout properties based on screen size
          final int statCrossAxisCount = isMobile ? 1 : isTablet ? 2 : 4;
          final double statChildAspectRatio = isMobile ? 4.0 : isTablet ? 3.3 : 2.9;
          final double padding = isMobile ? 12.0 : isTablet ? 16.0 : 18.0;


          // Your widget build
          return SingleChildScrollView(
            padding: EdgeInsets.all(padding),
            child: Column(
              children: [
                // Stats Cards
                GridView.count(
                  crossAxisCount: statCrossAxisCount,
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  mainAxisSpacing: 12,
                  crossAxisSpacing: 12,
                  childAspectRatio: statChildAspectRatio,
                  children: [
                    _StatCard(
                      title: "Total Devices",
                      value: allDevices.length.toString(),
                      icon: Icons.devices,
                      iconBg: Colors.blue,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                    _StatCard(
                      title: "Active",
                      value: totalActive.toString(),
                      icon: Icons.check_circle,
                      iconBg: Colors.green,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                    _StatCard(
                      title: "Inactive",
                      value: totalInactive.toString(),
                      icon: Icons.cancel,
                      iconBg: Colors.red,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                    _StatCard(
                      title: "Users",
                      value: users.length.toString(),
                      icon: Icons.people_alt,
                      iconBg: Colors.orange,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                  ],
                ),
                const SizedBox(height: 18),

                // Sections
                Column(
                  children: [
                  // Devices Section
                  _SectionCard(
                    title: "Devices",
                    cardColor: card,
                    strong: strong,
                    subtle: subtle,
                    child: isLoading
                        ? const Center(
                            child: Padding(
                              padding: EdgeInsets.all(24.0),
                              child: CircularProgressIndicator(),
                            ),
                          )
                        : Column(
                            children: [
                              // ðŸ”¹ Search field + filter
                              Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  _SearchField(
                                    hint: "Search a device",
                                    strong: strong,
                                    subtle: subtle,
                                    isDark: isDark,
                                    onChanged: (value) {
                                      setState(() {
                                        searchQuery = value.trim();
                                        devicesToShow = 4;
                                      });
                                    },
                                  ),
                                  const SizedBox(height: 12),
                                  // âœ… Responsive filter section
                                  LayoutBuilder(
                                    builder: (context, constraints) {
                                      final isMobile = constraints.maxWidth < 600;

                                      if (isMobile) {
                                        // ðŸ‘‰ Dropdown on mobile
                                        return Row(
                                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                          children: [
                                            DropdownButton<String>(
                                              value: filter,
                                              items: ["All", "Active", "Inactive"]
                                                  .map((e) => DropdownMenuItem(
                                                        value: e,
                                                        child: Text(e),
                                                      ))
                                                  .toList(),
                                              onChanged: (v) {
                                                if (v != null) setState(() => filter = v);
                                              },
                                            ),
                                            IconButton(
                                              tooltip: "Refresh",
                                              onPressed: () {
                                                fetchDevices();
                                                fetchAnomalies();
                                              },
                                              icon: Icon(Icons.refresh, color: strong),
                                            ),
                                          ],
                                        );
                                      } else {
                                        // ðŸ‘‰ Chips on larger screens
                                        return Wrap(
                                          spacing: 8,
                                          runSpacing: 8,
                                          crossAxisAlignment: WrapCrossAlignment.center,
                                          children: [
                                            _ChipFilter(
                                              value: filter,
                                              onChanged: (v) {
                                                setState(() => filter = v);
                                              },
                                              strong: strong,
                                              subtle: subtle,
                                              isDark: isDark,
                                            ),
                                            IconButton(
                                              tooltip: "Refresh",
                                              onPressed: () {
                                                fetchDevices();
                                                fetchAnomalies();
                                              },
                                              icon: Icon(Icons.refresh, color: strong),
                                            ),
                                          ],
                                        );
                                      }
                                    },
                                  ),
                                ],
                              ),
                              const SizedBox(height: 20),
                              const Divider(height: 1),
                              const SizedBox(height: 8),
                              if (filteredDevices.isEmpty)
                                Center(
                                  child: Text("No devices found", style: TextStyle(color: subtle)),
                                )
                              else
                                Column(
                                  children: [
                                    ...(filteredDevices.take(devicesToShow).map(
                                      (d) => Column(
                                        children: [
                                          InkWell(
                                            hoverColor: isDark
                                                  ? const Color(0xFF2C3E50).withOpacity(0.6) // Dark mode hover
                                                  : const Color(0xFF5BAA9D).withOpacity(0.9), // Light mode hover
                                            onTap: () {
                                              final deviceId = d['DeviceId'] ?? "Unknown";
                                              final topic = d['Topic'] ?? "Unknown";
                                              final mapped = _mapCategoryAndPrefix(topic);
                                              final sensorName = mapped.prefix.isNotEmpty
                                                  ? "${mapped.prefix}${deviceId.padLeft(3, '0')}"
                                                  : deviceId;
                                              final sequentialName = "${mapped.category}";
                                              Navigator.push(
                                                context,
                                                MaterialPageRoute(
                                                  builder: (context) => DeviceGraphPage(
                                                    deviceName: sensorName,
                                                    sequentialName: sequentialName,
                                                    backgroundImagePath: 'assets/backgroundd.jpg',
                                                  ),
                                                ),
                                              );
                                            },
                                            child: ListTile(
                                              leading: _StatusDot(
                                                color: d['isActive'] == true ? Colors.green : Colors.red,
                                              ),
                                              title: Text(
                                                "ID: ${d['DeviceId'] != null && d['Topic'] != null ? (_mapCategoryAndPrefix(d['Topic']).prefix.isNotEmpty ? "${_mapCategoryAndPrefix(d['Topic']).prefix}${d['DeviceId'].padLeft(3, '0')}" : d['DeviceId']) : "Unknown"}",
                                                style: TextStyle(
                                                  color: strong,
                                                  fontWeight: FontWeight.w700,
                                                  fontSize: 14,
                                                ),
                                                overflow: TextOverflow.ellipsis,
                                              ),
                                              subtitle: Text(
                                                "Name: ${d['Topic'] != null ? _mapCategoryAndPrefix(d['Topic']).category : "Unknown"}\nLast: ${d['lastReceivedTime']}",
                                                style: TextStyle(
                                                  color: subtle,
                                                  fontSize: 12,
                                                ),
                                                overflow: TextOverflow.ellipsis,
                                                maxLines: 2,
                                              ),
                                              trailing: Container(
                                                padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                                                decoration: BoxDecoration(
                                                  color: (d['isActive'] == true ? Colors.green : Colors.red).withOpacity(.12),
                                                  borderRadius: BorderRadius.circular(20),
                                                ),
                                                child: Text(
                                                  d['isActive'] == true ? "Active" : "Inactive",
                                                  style: TextStyle(
                                                    color: d['isActive'] == true ? Colors.green : Colors.red,
                                                    fontWeight: FontWeight.w700,
                                                  ),
                                                ),
                                              ),
                                            ),
                                          ),
                                          Divider(color: subtle.withOpacity(.12)),
                                        ],
                                      ),
                                    )).toList(),
                                    if (devicesToShow < filteredDevices.length)
                                      TextButton(
                                        onPressed: () {
                                          setState(() {
                                            devicesToShow = (devicesToShow + 4).clamp(0, filteredDevices.length);
                                          });
                                        },
                                        child: const Text("Show More"),
                                      )
                                    else if (filteredDevices.length > 4)
                                      TextButton(
                                        onPressed: () {
                                          setState(() {
                                            devicesToShow = 4;
                                          });
                                        },
                                        child: const Text("Show Less"),
                                      ),
                                  ],
                                ),
                            ],
                          ),
                  ),



                    // Users Section
                    _SectionCard(
                      title: "User Accounts",
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                      child: isUsersLoading
                          ? const Center(
                              child: Padding(
                                padding: EdgeInsets.all(24.0),
                                child: CircularProgressIndicator(),
                              ),
                            )
                          : users.isNotEmpty
                              ? Column(
                                  children: [
                                    Align(
                                      alignment: Alignment.centerLeft,
                                      child: Text(
                                        "Total ${users.length}",
                                        style: TextStyle(color: subtle),
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    const Divider(height: 1),
                                    const SizedBox(height: 8),
                                    Column(
                                      children: [
                                        ...(users.take(usersToShow).map(
                                          (u) => Column(
                                            children: [
                                              InkWell(
                                                hoverColor: isDark
                                                      ? const Color(0xFF2C3E50).withOpacity(0.6) // Dark mode hover
                                                      : const Color(0xFF5BAA9D).withOpacity(0.9), // Light mode hover
                                                onTap: () => _showUserDevices(u["email"]!),
                                                child: ListTile(
                                                  leading: CircleAvatar(
                                                    backgroundColor: Colors.blue.withOpacity(.12),
                                                    child: const Icon(Icons.person, color: Colors.blue),
                                                  ),
                                                  title: Text(
                                                    u["name"] ?? "",
                                                    style: TextStyle(
                                                      color: strong,
                                                      fontWeight: FontWeight.w700,
                                                          fontSize: getResponsiveFontSize(context, 12, 14), // ðŸ‘ˆ mobile=12, pc=14

                                                    ),
                                                    overflow: TextOverflow.ellipsis,
                                                    maxLines: 1,
                                                  ),
                                                  subtitle: Text(
                                                    "${u["email"]} â€¢ ${u["role"]}",
                                                    style: TextStyle(
                                                      color: subtle,
                                                           fontSize: getResponsiveFontSize(context, 10, 12), // ðŸ‘ˆ mobile=9, pc=10

                                                    ),
                                                    overflow: TextOverflow.ellipsis,
                                                    maxLines: 2,
                                                  ),
                                                  trailing: Row(
                                                    mainAxisSize: MainAxisSize.min,
                                                    children: [
                                                      IconButton(
                                                        tooltip: "Add Device",
                                                        onPressed: () => _showAddDeviceDialog(u["email"]!),
                                                        icon: const Icon(Icons.add, color: Colors.blue),
                                                      ),
                                                      IconButton(
                                                        tooltip: "Delete",
                                                        onPressed: () => _deleteUser(u["email"]!),
                                                        icon: const Icon(Icons.delete, color: Colors.red),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ),
                                              Divider(color: subtle.withOpacity(.12)),
                                            ],
                                          ),
                                        )),
                                        if (usersToShow < users.length)
                                          TextButton(
                                            onPressed: () {
                                              setState(() {
                                                usersToShow = (usersToShow + 4).clamp(0, users.length);
                                              });
                                            },
                                            child: const Text("Show More"),
                                          )
                                        else if (users.length > 4)
                                          TextButton(
                                            onPressed: () {
                                              setState(() {
                                                usersToShow = 4;
                                              });
                                            },
                                            child: const Text("Show Less"),
                                          ),
                                      ],
                                    ),
                                  ],
                                )
                              : Center(
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text("No users available", style: TextStyle(color: subtle)),
                                      const SizedBox(height: 8),
                                      ElevatedButton(
                                        onPressed: fetchUsers,
                                        child: const Text("Retry"),
                                      ),
                                    ],
                                  ),
                                ),
                    ),

                  ],
                ),
              ],
            ),
          );

        },
      ),
    );
  }

  void _showDeviceDetails(Map<String, dynamic> d) {
    showDialog(
      context: context,
      builder: (_) {
        final active = d['isActive'] == true;
        return AlertDialog(
          title: Text("Device ${d['DeviceId']}"),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Group: ${d['group']}"),
              const SizedBox(height: 6),
              Text("Topic: ${d['Topic']}"),
              const SizedBox(height: 6),
              Text("Last: ${d['lastReceivedTime']}"),
              const SizedBox(height: 6),
              Row(
                children: [
                  Text("Status: "),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
                    decoration: BoxDecoration(
                      color: (active ? Colors.green : Colors.red).withOpacity(.12),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      active ? "Active" : "Inactive",
                      style: TextStyle(color: active ? Colors.green : Colors.red, fontWeight: FontWeight.bold),
                    ),
                  ),
                ],
              ),
            ],
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: const Text("Close")),
          ],
        );
      },
    );
  }
}

class _StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color iconBg;
  final Color cardColor;
  final Color strong;
  final Color subtle;

  const _StatCard({
    required this.title,
    required this.value,
    required this.icon,
    required this.iconBg,
    required this.cardColor,
    required this.strong,
    required this.subtle,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      color: cardColor,
      elevation: 3,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Container(
              width: 44,
              height: 44,
              decoration: BoxDecoration(color: iconBg.withOpacity(.15), borderRadius: BorderRadius.circular(10)),
              child: Icon(icon, color: iconBg, size: 26),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(value, style: TextStyle(color: strong, fontSize: 20, fontWeight: FontWeight.w800)),
                  const SizedBox(height: 2),
                  Text(title, style: TextStyle(color: subtle, fontSize: 13)),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _SectionCard extends StatelessWidget {
  final String title;
  final Widget child;
  final Color cardColor;
  final Color strong;
  final Color subtle;

  const _SectionCard({
    required this.title,
    required this.child,
    required this.cardColor,
    required this.strong,
    required this.subtle,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      color: cardColor,
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.fromLTRB(14, 12, 14, 14),
        child: Column(
          children: [
            Row(
              children: [
                Text(title, style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800)),
              ],
            ),
            const SizedBox(height: 10),
            child,
          ],
        ),
      ),
    );
  }
}

class _ChipFilter extends StatelessWidget {
  final String value;
  final void Function(String) onChanged;
  final Color strong;
  final Color subtle;
  final bool isDark;

  const _ChipFilter({
    required this.value,
    required this.onChanged,
    required this.strong,
    required this.subtle,
    required this.isDark,
  });

  @override
  Widget build(BuildContext context) {
    final options = ["All", "Active", "Inactive"];
    return Wrap(
      spacing: 8,
      children: options.map((opt) {
        final selected = value == opt;
        return ChoiceChip(
          label: Text(
            opt,
            style: TextStyle(
              color: selected ? Colors.white : strong,
              fontWeight: FontWeight.w600,
            ),
          ),
          selected: selected,
          selectedColor: opt == "Active" ? Colors.green : (opt == "Inactive" ? Colors.red : Colors.blue),
          backgroundColor: (isDark ? Colors.white10 : Colors.black12).withOpacity(.06),
          onSelected: (_) => onChanged(opt),
        );
      }).toList(),
    );
  }
}

class _SearchField extends StatelessWidget {
  final String hint;
  final void Function(String) onChanged;
  final Color strong;
  final Color subtle;
  final bool isDark;

  const _SearchField({
    required this.hint,
    required this.onChanged,
    required this.strong,
    required this.subtle,
    required this.isDark,
  });

  @override
  Widget build(BuildContext context) {
    return TextField(
      onChanged: onChanged,
      style: TextStyle(color: strong),
      decoration: InputDecoration(
        prefixIcon: Icon(Icons.search, color: subtle),
        hintText: hint,
        hintStyle: TextStyle(color: subtle),
        filled: true,
        fillColor: (isDark ? Colors.white10 : Colors.black12).withOpacity(.06),
        contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: subtle.withOpacity(.2)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: subtle.withOpacity(.15)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Theme.of(context).colorScheme.primary, width: 1.2),
        ),
      ),
    );
  }
}

class _StatusDot extends StatelessWidget {
  final Color color;
  const _StatusDot({required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 14,
      height: 14,
      decoration: BoxDecoration(
        color: color,
        shape: BoxShape.circle,
        boxShadow: [BoxShadow(color: color.withOpacity(.35), blurRadius: 8, spreadRadius: 1)],
      ),
    );
  }
}

class _LegendDot extends StatelessWidget {
  final Color color;
  final String text;
  const _LegendDot({required this.color, required this.text});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(color: color, borderRadius: BorderRadius.circular(3)),
        ),
        const SizedBox(width: 6),
        Text(text, style: const TextStyle(fontWeight: FontWeight.w600)),
      ],
    );
  }
}